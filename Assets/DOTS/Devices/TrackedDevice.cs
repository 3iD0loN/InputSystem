//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated by DOTS Input Device Code Generator
//     version 1.1.0
//     from TrackedDevice Layout
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Entities;
using Unity.Input;

#pragma warning disable CS0169

namespace Unity.Input
{
    public struct TrackedDeviceEvent : IInputData
    {
        public enum Id : uint
        {
            TrackingState = 0,
            IsTracked = 32,
            DevicePositionX = 64,
            DevicePositionY = 96,
            DevicePositionZ = 128,
            DeviceRotationX = 192,
            DeviceRotationY = 224,
            DeviceRotationZ = 256,
            DeviceRotationW = 288,
        }

        public int TrackingState;
        private int Padding0;
        public float DevicePositionX;
        public float DevicePositionY;
        public float DevicePositionZ;
        private int Padding1;
        public float DeviceRotationX;
        public float DeviceRotationY;
        public float DeviceRotationZ;
        public float DeviceRotationW;

        public unsafe bool IsTracked
        {
            get
            {
                fixed(void* thisPtr = &this)
                return (((byte*)thisPtr)[4] & ((1 << 0) & 0xFF)) != 0;
            }
            set
            {
                fixed(void* thisPtr = &this)
                if (value)
                    ((byte*)thisPtr)[4] |= (1 << 0) & 0xFF;
                else
                    ((byte*)thisPtr)[4] &= ~(1 << 0) & 0xFF;
            }
        }

        public uint Format => 2062885223;

        public DOTSInput.InputPipeline InputPipelineParts
        {
            get
            {
                var structMappings = new NativeArray<DOTSInput.InputStructMapping>(kStructMappingCount, Allocator.Persistent);
                var transforms = new NativeArray<DOTSInput.InputTransform>(kTransformCount, Allocator.Persistent);


                // TrackedDeviceEvent -> TrackedDeviceInput
                transforms[0] = new DOTSInput.InputTransform
                {
                    Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.BitToButton),
                    InputId1 = (uint)Id.IsTracked,
                    OutputId = (uint)TrackedDeviceInput.Id.IsTracked
                };
                transforms[1] = new DOTSInput.InputTransform
                {
                    Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.FloatToAxis),
                    InputId1 = (uint)Id.DevicePositionX,
                    OutputId = (uint)TrackedDeviceInput.Id.DevicePositionX
                };
                transforms[2] = new DOTSInput.InputTransform
                {
                    Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.FloatToAxis),
                    InputId1 = (uint)Id.DevicePositionY,
                    OutputId = (uint)TrackedDeviceInput.Id.DevicePositionY
                };
                transforms[3] = new DOTSInput.InputTransform
                {
                    Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.FloatToAxis),
                    InputId1 = (uint)Id.DevicePositionZ,
                    OutputId = (uint)TrackedDeviceInput.Id.DevicePositionZ
                };
                transforms[4] = new DOTSInput.InputTransform
                {
                    Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.FloatToAxis),
                    InputId1 = (uint)Id.DeviceRotationX,
                    OutputId = (uint)TrackedDeviceInput.Id.DeviceRotationX
                };
                transforms[5] = new DOTSInput.InputTransform
                {
                    Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.FloatToAxis),
                    InputId1 = (uint)Id.DeviceRotationY,
                    OutputId = (uint)TrackedDeviceInput.Id.DeviceRotationY
                };
                transforms[6] = new DOTSInput.InputTransform
                {
                    Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.FloatToAxis),
                    InputId1 = (uint)Id.DeviceRotationZ,
                    OutputId = (uint)TrackedDeviceInput.Id.DeviceRotationZ
                };
                transforms[7] = new DOTSInput.InputTransform
                {
                    Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.FloatToAxis),
                    InputId1 = (uint)Id.DeviceRotationW,
                    OutputId = (uint)TrackedDeviceInput.Id.DeviceRotationW
                };
                structMappings[0] = new DOTSInput.InputStructMapping
                {
                    InputFormat = 2062885223,
                    OutputFormat = 462727361,
                    InputSizeInBytes = (uint)UnsafeUtility.SizeOf<TrackedDeviceEvent>(),
                    OutputSizeInBytes = (uint)UnsafeUtility.SizeOf<TrackedDeviceInput>(),
                    TransformStartIndex = 0,
                    TransformCount = 8
                };

                return new DOTSInput.InputPipeline
                {
                    StructMappings = structMappings,
                    Transforms = transforms,
                };
            }
        }

        private const int kStructMappingCount = 1;
        private const int kTransformCount = 8;
    }

    public struct TrackedDeviceInput : IComponentData, IInputData
    {
        public Float3Input DevicePosition;
        public FloatInput DevicePositionX;
        public FloatInput DevicePositionY;
        public FloatInput DevicePositionZ;
        public FloatInput DeviceRotationX;
        public FloatInput DeviceRotationY;
        public FloatInput DeviceRotationZ;
        public FloatInput DeviceRotationW;
        public ButtonInput IsTracked;

        public enum Id : uint
        {
            DevicePosition = 0,
            DevicePositionX = 96,
            DevicePositionY = 128,
            DevicePositionZ = 160,
            DeviceRotationX = 192,
            DeviceRotationY = 224,
            DeviceRotationZ = 256,
            DeviceRotationW = 288,
            IsTracked = 320,
        }
        public uint Format => 462727361;

        public DOTSInput.InputPipeline InputPipelineParts
        {
            get
            {
                var structMappings = kStructMappingCount > 0 ? new NativeArray<DOTSInput.InputStructMapping>(kStructMappingCount, Allocator.Persistent) : default;
                var transforms = kTransformCount > 0 ? new NativeArray<DOTSInput.InputTransform>(kTransformCount, Allocator.Persistent) : default;

                transforms[0] = new DOTSInput.InputTransform
                {
                    Operation = DOTSInput.ToTransformOperation(DOTSInput.Combination.ThreeAxesToOneFloat3),
                    InputId1 = (uint)Id.DevicePositionX,
                    InputId2 = (uint)Id.DevicePositionY,
                    InputId3 = (uint)Id.DevicePositionZ,
                    OutputId = (uint)Id.DevicePosition
                };

                structMappings[0] = new DOTSInput.InputStructMapping
                {
                    InputFormat = 462727361,
                    OutputFormat = 462727361,
                    InputSizeInBytes = (uint)UnsafeUtility.SizeOf<TrackedDeviceInput>(),
                    OutputSizeInBytes = (uint)UnsafeUtility.SizeOf<TrackedDeviceInput>(),
                    TransformStartIndex = 0,
                    TransformCount = 1
                };
                return new DOTSInput.InputPipeline
                {
                    StructMappings = structMappings,
                    Transforms = transforms,
                };
            }
        }

        private const int kStructMappingCount = 1;
        private const int kTransformCount = 1;
    }
}
