#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine.InputSystem.Controls;
using UnityEngine.InputSystem.Layouts;
using UnityEngine.InputSystem.LowLevel;
using UnityEngine.InputSystem.Utilities;

////TODO: Allow user to specify base JobSystem so that the user can actually extend InputSystem<T> with custom functionality

////REVIEW: conditionalize our DOTS editor support to when DOTS stuff is installed in the project?

////REVIEW: A better way for implementing InputPipelineParts would be to have all the data statically in memory

//how should we handle devices like Touchscreen that use IInputStateCallbackReceiver? add list of valid state formats to InputControlLayout?

namespace UnityEngine.InputSystem.Editor
{
    internal static class InputDotsCodeGenerator
    {
        private const string kDeviceLayoutsFolder = "Assets/DOTS/Devices";
        private const string kDeviceLayoutsNamespace = "Unity.Input";

        [MenuItem("DOTS/Regenerate Input Pipelines for Devices")]
        public static void GenerateCodeForDeviceLayouts()
        {
            if (!Directory.Exists(kDeviceLayoutsFolder))
                Directory.CreateDirectory(kDeviceLayoutsFolder);

            var initCode = new InputActionCodeGenerator.Writer { buffer = new StringBuilder() };
            initCode.WriteLine(CSharpCodeHelpers.MakeAutoGeneratedCodeHeader("DOTS Input Device Code Generator",
                InputSystem.version.ToString()));
            initCode.WriteLine("using System.Collections.Generic;");
            initCode.WriteLine();
            initCode.WriteLine("namespace Unity.Input");
            initCode.BeginBlock();
            initCode.WriteLine("partial class DOTSInput");
            initCode.BeginBlock();
            initCode.WriteLine("internal static void AddDevicePipelineFragments(Dictionary<ulong, InputPipelineFragment> dictionary)");
            initCode.BeginBlock();

            foreach (var layout in InputControlLayout.s_Layouts.GetAllLayouts().Where(
                l =>
                {
                    var loadedLayout = InputSystem.LoadLayout(l);
                    return loadedLayout.isDeviceLayout && loadedLayout.controls.Count > 0 &&
                    loadedLayout.type != null &&
                    !string.IsNullOrEmpty(loadedLayout.type.Namespace) &&
                    loadedLayout.type.Namespace.StartsWith("UnityEngine.InputSystem");
                }).OrderBy(l => l.ToString()))
            {
                initCode.WriteLine($"AddPipelineFragments<{layout}Event>(dictionary);");
                initCode.WriteLine($"AddPipelineFragments<{layout}Input>(dictionary);");

                var code = GenerateECSInputPipeline(layout, kDeviceLayoutsNamespace);
                var filePath = Path.Combine(kDeviceLayoutsFolder, layout + ".cs");

                // Don't touch file if contents are the same.
                if (File.Exists(filePath) && File.ReadAllText(filePath).WithAllWhitespaceStripped() == code.WithAllWhitespaceStripped())
                    continue;

                AssetDatabase.MakeEditable(filePath);
                File.WriteAllText(filePath, code);
            }

            initCode.EndBlock();
            initCode.EndBlock();
            initCode.EndBlock();

            var initFilePath = Path.Combine(kDeviceLayoutsFolder, "Init.cs");
            if (!File.Exists(initFilePath) || File.ReadAllText(initFilePath).WithAllWhitespaceStripped() !=
                initCode.buffer.ToString().WithAllWhitespaceStripped())
            {
                AssetDatabase.MakeEditable(initFilePath);
                File.WriteAllText(initFilePath, initCode.buffer.ToString());
            }

            AssetDatabase.Refresh();
        }

        public static string GenerateECSInputPipeline(string layoutName, string @namespace = null)
        {
            var device = InputDevice.Build<InputDevice>(layoutName);

            var writer = new InputActionCodeGenerator.Writer { buffer = new StringBuilder() };
            writer.WriteLine(CSharpCodeHelpers.MakeAutoGeneratedCodeHeader("DOTS Input Device Code Generator", InputSystem.version.ToString(), $"{layoutName} Layout"));

            // Usings.
            writer.WriteLine("using Unity.Collections;");
            writer.WriteLine("using Unity.Collections.LowLevel.Unsafe;");
            writer.WriteLine("using Unity.Entities;");
            writer.WriteLine("using Unity.Input;");
            writer.WriteLine();

            // Pragmas.
            writer.WriteLine("#pragma warning disable CS0169"); // Padding fields are private and never written to.
            writer.WriteLine();

            // Namespace.
            if (@namespace != null)
            {
                writer.WriteLine("namespace " + @namespace);
                writer.BeginBlock();
            }

            // Event struct. Follows exact memory layout of device. Used to send input
            // for the device.
            var eventName = layoutName + "Event";
            writer.WriteLine($"public struct {eventName} : IInputData");
            writer.BeginBlock();
            var allNonSyntheticLeafControlsSortedByOffset = device.allControls
                .Where(c => c.children.Count == 0 && !c.synthetic)
                .ToList();
            allNonSyntheticLeafControlsSortedByOffset.Sort((a, b) =>
                Comparer<uint>.Default.Compare(a.stateBlock.byteOffset * 8 + a.stateBlock.bitOffset,
                    b.stateBlock.byteOffset * 8 + b.stateBlock.bitOffset));
            var paddingCount = 0;
            var currentByteOffset = 0;
            // Emit IDs.
            writer.WriteLine("public enum Id : uint");
            writer.BeginBlock();
            foreach (var control in allNonSyntheticLeafControlsSortedByOffset)
                writer.WriteLine($"{MapControlToId(control)} = {control.stateBlock.byteOffset * 8 + control.stateBlock.bitOffset},");
            writer.EndBlock();
            // Emit fields.
            writer.WriteLine();
            foreach (var control in allNonSyntheticLeafControlsSortedByOffset)
            {
                var stateBlock = control.stateBlock;

                // Skip bit-addressed controls. Those we don't expose as fields but rather
                // as properties in a second pass.
                if (stateBlock.bitOffset % 8 != 0 || stateBlock.sizeInBits % 8 != 0 || stateBlock.sizeInBits > sizeof(double) * 8)
                    continue;

                // Determine primitive type to use for control.
                var type = InputStateBlock.GetTypeFromPrimitiveFormat(stateBlock.format);
                if (type == null)
                    continue;

                // Emit padding fields, if necessary.
                WritePaddingFields(ref writer, ref currentByteOffset, (int)stateBlock.byteOffset, ref paddingCount);

                writer.WriteLine($"public {TypeHelpers.GetNiceTypeName(type)} {MapControlToId(control)};");

                currentByteOffset += (int)stateBlock.alignedSizeInBytes;
            }
            WritePaddingFields(ref writer, ref currentByteOffset, (int)device.stateBlock.alignedSizeInBytes.AlignToMultipleOf(4), ref paddingCount);
            // Emit bitfield properties.
            foreach (var control in allNonSyntheticLeafControlsSortedByOffset)
            {
                var stateBlock = control.stateBlock;

                if (stateBlock.sizeInBits % 8 == 0 && stateBlock.bitOffset == 0)
                    continue;

                if (stateBlock.sizeInBits == 1 && control is ButtonControl)
                {
                    var name = MapControlToId(control);
                    var offset = stateBlock.byteOffset * 8 + stateBlock.bitOffset;
                    var byteOffset = offset / 8;
                    var bitOffset = offset % 8;

                    writer.WriteLine();
                    writer.WriteLine($"public unsafe bool {name}");
                    writer.BeginBlock();
                    writer.WriteLine("get");
                    writer.BeginBlock();
                    writer.WriteLine("fixed (void* thisPtr = &this)");
                    writer.WriteLine($"    return (((byte*)thisPtr)[{byteOffset}] & ((1 << {bitOffset}) & 0xFF)) != 0;");
                    writer.EndBlock();
                    writer.WriteLine("set");
                    writer.BeginBlock();
                    writer.WriteLine("fixed (void* thisPtr = &this)");
                    writer.WriteLine("    if (value)");
                    writer.WriteLine($"        ((byte*)thisPtr)[{byteOffset}] |= (1 << {bitOffset}) & 0xFF;");
                    writer.WriteLine("    else");
                    writer.WriteLine($"        ((byte*)thisPtr)[{byteOffset}] &= ~(1 << {bitOffset}) & 0xFF;");
                    writer.EndBlock();
                    writer.EndBlock();
                }
                else
                    continue; ////TODO
            }
            // Format.
            var eventFormatCode = CRC32.crc32(eventName);
            writer.WriteLine();
            writer.WriteLine($"public uint Format => {eventFormatCode};");
            // Pipeline fragments.
            writer.WriteLine();
            writer.WriteLine("public DOTSInput.InputPipeline InputPipelineParts");
            writer.BeginBlock();
            writer.WriteLine("get");
            writer.BeginBlock();
            writer.WriteLine("var structMappings = new NativeArray<DOTSInput.InputStructMapping>(kStructMappingCount, Allocator.Persistent);");
            writer.WriteLine("var transforms = new NativeArray<DOTSInput.InputTransform>(kTransformCount, Allocator.Persistent);");
            writer.WriteLine();
            var structMappingCount = 0;
            var transformCount = 0;
            foreach (var targetLayout in InputControlLayout.s_Layouts.GetBaseLayouts(new InternedString(layoutName), includeSelf: true))
            {
                // Skip devices that have no controls (like Sensor).
                if (InputControlLayout.s_Layouts.TryLoadLayout(targetLayout).controls.Count == 0)
                    continue;

                var targetDevice = InputDevice.Build<InputDevice>(targetLayout);
                var targetFormat = targetLayout + "Input";
                var targetFormatCode = CRC32.crc32(targetFormat);

                writer.WriteLine();
                writer.WriteLine($"// {eventName} -> {targetFormat}");

                // Transforms.
                var targetTransformStartIndex = transformCount;
                foreach (var control in allNonSyntheticLeafControlsSortedByOffset)
                {
                    // Skip if control does not exist on target device.
                    if (InputControlPath.TryFindChild(targetDevice, control.pathRelativeToDevice) == null)
                        continue;

                    ////TODO: this should be extensible so users can add support for their own controls
                    // Determine transform operation needed for the control.
                    var stateFormat = control.stateBlock.format;
                    string operation;
                    if (control is ButtonControl)
                    {
                        if (stateFormat == InputStateBlock.FormatBit)
                        {
                            if (control.stateBlock.sizeInBits == 1)
                                operation = "Conversion.BitToButton";
                            else
                                continue; ////TODO
                        }
                        else if (stateFormat == InputStateBlock.FormatByte)
                        {
                            operation = "Conversion.ByteToButton";
                        }
                        else if (stateFormat == InputStateBlock.FormatSByte)
                        {
                            operation = "Conversion.SByteToButton";
                        }
                        else
                            continue; ////TODO
                    }
                    else if (control is AxisControl)
                    {
                        //may be half-axis!
                        if (stateFormat == InputStateBlock.FormatByte)
                        {
                            operation = "Conversion.ByteToAxis";
                        }
                        else if (stateFormat == InputStateBlock.FormatFloat)
                        {
                            operation = "Conversion.FloatToAxis";
                        }
                        else
                            continue; ///TODO
                    }
                    else
                        continue; ////TODO

                    // Add transform.
                    var controlId = MapControlToId(control);
                    writer.WriteLine($"transforms[{transformCount}] = new DOTSInput.InputTransform");
                    writer.BeginBlock();
                    writer.WriteLine($"Operation = DOTSInput.ToTransformOperation(DOTSInput.{operation}),");
                    writer.WriteLine($"InputId1 = (uint)Id.{controlId},");
                    writer.WriteLine($"OutputId = (uint){targetFormat}.Id.{controlId}");
                    writer.EndBlock(true);
                    ++transformCount;
                }

                // Struct mapping.
                writer.WriteLine($"structMappings[{structMappingCount}] = new DOTSInput.InputStructMapping");
                writer.BeginBlock();
                writer.WriteLine($"InputFormat = {eventFormatCode},");
                writer.WriteLine($"OutputFormat = {targetFormatCode},");
                writer.WriteLine($"InputSizeInBytes = (uint)UnsafeUtility.SizeOf<{eventName}>(),");
                writer.WriteLine($"OutputSizeInBytes = (uint)UnsafeUtility.SizeOf<{targetFormat}>(),");
                writer.WriteLine($"TransformStartIndex = {targetTransformStartIndex},");
                writer.WriteLine($"TransformCount = {transformCount - targetTransformStartIndex}");
                writer.EndBlock(true);
                ++structMappingCount;
            }
            writer.WriteLine();
            writer.WriteLine("return new DOTSInput.InputPipeline");
            writer.BeginBlock();
            writer.WriteLine("StructMappings = structMappings,");
            writer.WriteLine("Transforms = transforms,");
            writer.EndBlock(true);
            writer.EndBlock();
            writer.EndBlock();
            writer.WriteLine();
            writer.WriteLine($"private const int kStructMappingCount = {structMappingCount};");
            writer.WriteLine($"private const int kTransformCount = {transformCount};");
            writer.EndBlock();

            ////TODO: for these to be useful as components, we need to have a way to update them when sitting on an entity
            // Input component.
            var componentName = layoutName + "Input";
            writer.WriteLine();
            writer.WriteLine($"public struct {componentName} : IComponentData, IInputData");
            writer.BeginBlock();

            // Controls. Gather them first so that we can arrange them in optimal sequence.
            var componentControlTypes = new Dictionary<string, string>();
            var componentControlSizes = new Dictionary<string, uint>();
            foreach (var control in device.allControls)
            {
                string inputType;
                int inputSizeInBytes;

                ////TODO: this needs to be extensible
                if (control is ButtonControl)
                {
                    if (control.stateBlock.sizeInBits == 1)
                    {
                        inputType = "ButtonInput";
                        inputSizeInBytes = 1;
                    }
                    else
                    {
                        // This is a button with more than a true/false state. Give it both a button
                        // and a half-axis input.
                        inputType = "HalfAxisInput";
                        inputSizeInBytes = 4;

                        var buttonName = "Button" + MapControlToId(control);
                        componentControlSizes[buttonName] = 1;
                        componentControlTypes[buttonName] = "ButtonInput";
                    }
                }
                else if (control is AxisControl)
                {
                    inputSizeInBytes = 4;
                    if (control.m_MinValue == PrimitiveValue.FromSingle(0) && control.m_MaxValue == PrimitiveValue.FromSingle(1))
                        inputType = "HalfAxisInput";
                    else if (control.m_MinValue == PrimitiveValue.FromSingle(-1) && control.m_MaxValue == PrimitiveValue.FromSingle(1))
                        inputType = "AxisInput";
                    else
                        inputType = "FloatInput";
                }
                else if (control is Vector2Control)
                {
                    inputType = "Float2Input";
                    inputSizeInBytes = 8;
                }
                else if (control is Vector3Control)
                {
                    inputType = "Float3Input";
                    inputSizeInBytes = 12;
                }
                else
                    continue; ////TODO

                var name = MapControlToId(control);
                componentControlTypes[name] = inputType;
                componentControlSizes[name] = (uint)inputSizeInBytes;
            }
            var componentControlOffsets = new Dictionary<string, uint>();
            currentByteOffset = 0;
            foreach (var control in componentControlSizes.OrderByDescending(p => p.Value))
            {
                componentControlOffsets[control.Key] = (uint)currentByteOffset * 8;
                writer.WriteLine($"public {componentControlTypes[control.Key]} {control.Key};");
                currentByteOffset += (int)componentControlSizes[control.Key];
            }

            // IDs.
            writer.WriteLine();
            writer.WriteLine("public enum Id : uint");
            writer.BeginBlock();
            foreach (var entry in componentControlOffsets)
                writer.WriteLine($"{entry.Key} = {entry.Value},");
            writer.EndBlock();

            // Format.
            var componentFormatCode = CRC32.crc32(componentName);
            writer.WriteLine($"public uint Format => {componentFormatCode};");

            // Pipeline parts.
            writer.WriteLine();
            writer.WriteLine("public DOTSInput.InputPipeline InputPipelineParts");
            writer.BeginBlock();
            writer.WriteLine("get");
            writer.BeginBlock();
            writer.WriteLine(
                "var structMappings = kStructMappingCount > 0 ? new NativeArray<DOTSInput.InputStructMapping>(kStructMappingCount, Allocator.Persistent) : default;");
            writer.WriteLine(
                "var transforms = kTransformCount > 0 ? new NativeArray<DOTSInput.InputTransform>(kTransformCount, Allocator.Persistent) : default;");
            structMappingCount = 0;
            transformCount = 0;
            writer.WriteLine();
            // Identity transform.
            // Every leaf, non-synthetic control is considered a primary control. Go through
            // all secondary controls and add transforms to populate them from primary control
            // values.
            var identityTransformStartIndex = transformCount;
            foreach (var control in device.allControls.Where(c => !allNonSyntheticLeafControlsSortedByOffset.Contains(c)))
            {
                ////TODO: need to get controls like <Mouse>/press to be written to from <Mouse>/leftButton

                if (control is Vector2Control vector2)
                {
                    writer.WriteLine($"transforms[{transformCount++}] = new DOTSInput.InputTransform");
                    writer.BeginBlock();
                    writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Combination.TwoAxesToOneFloat2),");
                    writer.WriteLine($"InputId1 = (uint)Id.{MapControlToId(vector2.x)},");
                    writer.WriteLine($"InputId2 = (uint)Id.{MapControlToId(vector2.y)},");
                    writer.WriteLine($"OutputId = (uint)Id.{MapControlToId(control)}");
                    writer.EndBlock(true);
                }
                else if (control is Vector3Control vector3)
                {
                    writer.WriteLine($"transforms[{transformCount++}] = new DOTSInput.InputTransform");
                    writer.BeginBlock();
                    writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Combination.ThreeAxesToOneFloat3),");
                    writer.WriteLine($"InputId1 = (uint)Id.{MapControlToId(vector3.x)},");
                    writer.WriteLine($"InputId2 = (uint)Id.{MapControlToId(vector3.y)},");
                    writer.WriteLine($"InputId3 = (uint)Id.{MapControlToId(vector3.z)},");
                    writer.WriteLine($"OutputId = (uint)Id.{MapControlToId(control)}");
                    writer.EndBlock(true);
                }
                else if (control.parent is StickControl stick)
                {
                    if (control == stick.up)
                    {
                        writer.WriteLine($"transforms[{transformCount++}] = new DOTSInput.InputTransform");
                        writer.BeginBlock();
                        writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.PositiveAxisToHalfAxis),");
                        writer.WriteLine($"InputId1 = (uint)Id.{MapControlToId(stick.y)},");
                        writer.WriteLine($"OutputId = (uint)Id.{MapControlToId(stick.up)}");
                        writer.EndBlock(true);

                        writer.WriteLine($"transforms[{transformCount++}] = new DOTSInput.InputTransform");
                        writer.BeginBlock();
                        writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.HalfAxisToButton),");
                        writer.WriteLine($"InputId1 = (uint)Id.{MapControlToId(stick.up)},");
                        writer.WriteLine($"OutputId = (uint)Id.Button{MapControlToId(stick.up)}");
                        writer.EndBlock(true);
                    }
                    else if (control == stick.down)
                    {
                        writer.WriteLine($"transforms[{transformCount++}] = new DOTSInput.InputTransform");
                        writer.BeginBlock();
                        writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.NegativeAxisToHalfAxis),");
                        writer.WriteLine($"InputId1 = (uint)Id.{MapControlToId(stick.y)},");
                        writer.WriteLine($"OutputId = (uint)Id.{MapControlToId(stick.down)}");
                        writer.EndBlock(true);

                        writer.WriteLine($"transforms[{transformCount++}] = new DOTSInput.InputTransform");
                        writer.BeginBlock();
                        writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.HalfAxisToButton),");
                        writer.WriteLine($"InputId1 = (uint)Id.{MapControlToId(stick.down)},");
                        writer.WriteLine($"OutputId = (uint)Id.Button{MapControlToId(stick.down)}");
                        writer.EndBlock(true);
                    }
                    else if (control == stick.right)
                    {
                        writer.WriteLine($"transforms[{transformCount++}] = new DOTSInput.InputTransform");
                        writer.BeginBlock();
                        writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.PositiveAxisToHalfAxis),");
                        writer.WriteLine($"InputId1 = (uint)Id.{MapControlToId(stick.x)},");
                        writer.WriteLine($"OutputId = (uint)Id.{MapControlToId(stick.right)}");
                        writer.EndBlock(true);

                        writer.WriteLine($"transforms[{transformCount++}] = new DOTSInput.InputTransform");
                        writer.BeginBlock();
                        writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.HalfAxisToButton),");
                        writer.WriteLine($"InputId1 = (uint)Id.{MapControlToId(stick.right)},");
                        writer.WriteLine($"OutputId = (uint)Id.Button{MapControlToId(stick.right)}");
                        writer.EndBlock(true);
                    }
                    else if (control == stick.left)
                    {
                        writer.WriteLine($"transforms[{transformCount++}] = new DOTSInput.InputTransform");
                        writer.BeginBlock();
                        writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.NegativeAxisToHalfAxis),");
                        writer.WriteLine($"InputId1 = (uint)Id.{MapControlToId(stick.x)},");
                        writer.WriteLine($"OutputId = (uint)Id.{MapControlToId(stick.left)}");
                        writer.EndBlock(true);

                        writer.WriteLine($"transforms[{transformCount++}] = new DOTSInput.InputTransform");
                        writer.BeginBlock();
                        writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Conversion.HalfAxisToButton),");
                        writer.WriteLine($"InputId1 = (uint)Id.{MapControlToId(stick.left)},");
                        writer.WriteLine($"OutputId = (uint)Id.Button{MapControlToId(stick.left)}");
                        writer.EndBlock(true);
                    }
                    else
                        continue;////TODO
                }
                else
                {
                    // See if there is another non-synthetic control that has the same memory state block.
                    // If so, we're probably looking at a useStateFrom control.
                    var usesStateFromControl = device.allControls.FirstOrDefault(c => !c.synthetic && c.stateBlock == control.stateBlock);
                    if (usesStateFromControl != null)
                    {
                        ////TODO
                    }
                    else
                    {
                        continue; ////TODO
                    }
                }
            }
            if (transformCount != identityTransformStartIndex)
            {
                writer.WriteLine();
                writer.WriteLine($"structMappings[{structMappingCount}] = new DOTSInput.InputStructMapping");
                writer.BeginBlock();
                writer.WriteLine($"InputFormat = {componentFormatCode},");
                writer.WriteLine($"OutputFormat = {componentFormatCode},");
                writer.WriteLine($"InputSizeInBytes = (uint)UnsafeUtility.SizeOf<{componentName}>(),");
                writer.WriteLine($"OutputSizeInBytes = (uint)UnsafeUtility.SizeOf<{componentName}>(),");
                writer.WriteLine($"TransformStartIndex = {identityTransformStartIndex},");
                writer.WriteLine($"TransformCount = {transformCount - identityTransformStartIndex}");
                writer.EndBlock(true);
                ++structMappingCount;
            }
            writer.WriteLine("return new DOTSInput.InputPipeline");
            writer.BeginBlock();
            writer.WriteLine("StructMappings = structMappings,");
            writer.WriteLine("Transforms = transforms,");
            writer.EndBlock(true);
            writer.EndBlock();
            writer.EndBlock();
            writer.WriteLine();
            writer.WriteLine($"private const int kStructMappingCount = {structMappingCount};");
            writer.WriteLine($"private const int kTransformCount = {transformCount};");

            writer.EndBlock();

            if (@namespace != null)
                writer.EndBlock();

            return writer.buffer.ToString();
        }

        public static bool GenerateECSComponents(string filePath, InputActionAsset asset, InputActionCodeGenerator.Options options)
        {
            ////TODO: control schemes

            var anyFileWritten = false;
            foreach (var actionMap in asset.actionMaps)
            {
                var componentName = CSharpCodeHelpers.MakeTypeName(actionMap.name);
                if (!string.IsNullOrEmpty(options.className))
                    componentName = options.className + componentName;
                componentName += "Input";

                var writer = new InputActionCodeGenerator.Writer { buffer = new StringBuilder() };

                writer.WriteLine("using Unity.Collections;");
                writer.WriteLine("using Unity.Entities;");
                writer.WriteLine("using Unity.Input;");
                writer.WriteLine();

                var haveNamespace = !string.IsNullOrEmpty(options.namespaceName);
                if (haveNamespace)
                {
                    writer.WriteLine("namespace " + options.namespaceName);
                    writer.BeginBlock();
                }

                writer.WriteLine("[GenerateAuthoringComponent]");
                writer.WriteLine($"public struct {componentName} : IComponentData, IInputData");
                writer.BeginBlock();
                writer.WriteLine("public int PlayerNumber;");
                writer.WriteLine();

                var currentBitOffset = 4 * 8; // sizeof(PlayerNumber)
                var ids = new Dictionary<string, int>();
                var sizes = new Dictionary<string, int>();

                // First values.
                foreach (var action in actionMap.Where(a => a.type == InputActionType.Value))
                {
                    string inputType = null;
                    var inputSizeInBits = 0;

                    switch (action.expectedControlType)
                    {
                        case "Stick":
                        case "Vector2":
                            inputType = "Float2Input";
                            inputSizeInBits = 8 * 8;
                            break;

                        case "Axis":
                            inputType = "AxisInput";
                            inputSizeInBits = 4 * 8;
                            break;
                    }

                    if (inputType == null)
                        continue;

                    var name = CSharpCodeHelpers.MakeIdentifier(action.name);
                    writer.WriteLine($"public {inputType} {name};");

                    ids[name] = currentBitOffset;
                    sizes[action.name] = inputSizeInBits;
                    currentBitOffset += inputSizeInBits;
                }

                // Then buttons.
                foreach (var action in actionMap.Where(a => a.type == InputActionType.Button))
                {
                    var name = CSharpCodeHelpers.MakeIdentifier(action.name);
                    writer.WriteLine($"public ButtonInput {name};");

                    ids[name] = currentBitOffset;
                    sizes[action.name] = 8;
                    currentBitOffset += 8;
                }

                // IDs.
                writer.WriteLine();
                writer.WriteLine("public enum Id : uint");
                writer.BeginBlock();
                foreach (var id in ids)
                    writer.WriteLine($"{id.Key} = {id.Value},");
                writer.EndBlock();

                // Format.
                var outputFormatName = componentName;
                var outputFormatCode = CRC32.crc32(outputFormatName);
                writer.WriteLine();
                writer.WriteLine($"public uint Format => {outputFormatCode};");

                // Input pipelines.
                writer.WriteLine();
                writer.WriteLine("public DOTSInput.InputPipeline InputPipelineParts");
                writer.BeginBlock();
                writer.WriteLine("get");
                writer.BeginBlock();
                writer.WriteLine("var structMappings = new NativeArray<DOTSInput.InputStructMapping>(kNumStructMappings, Allocator.Persistent);");
                writer.WriteLine("var transforms = new NativeArray<DOTSInput.InputTransform>(kNumTransforms, Allocator.Persistent);");
                var transformIndex = 0;
                var structMappingIndex = 0;
                foreach (var controlScheme in asset.controlSchemes)
                {
                    if (controlScheme.deviceRequirements.Count > 1)
                        throw new NotImplementedException("support for control schemes with more than a single device requirement");

                    ////TODO: support stuff such as LeftHand/RightHand (i.e. device usages)

                    // Determine input format ID.
                    var deviceLayout = InputControlPath.TryGetDeviceLayout(controlScheme.deviceRequirements[0].controlPath);
                    if (string.IsNullOrEmpty(deviceLayout))
                        continue;
                    var device = InputDevice.Build<InputDevice>(deviceLayout);
                    var inputFormatName = deviceLayout + "Input";
                    var inputFormatCode = CRC32.crc32(inputFormatName);

                    writer.WriteLine();
                    writer.WriteLine($"// {controlScheme.name}");

                    // Add transforms.
                    var transformStartIndex = transformIndex;
                    var bindings = actionMap.bindings;
                    for (var bindingIndex = 0; bindingIndex < bindings.Count; ++bindingIndex)
                    {
                        var binding = bindings[bindingIndex];

                        // We do not attempt anything special here if multiple bindings are
                        // added for a single action in a single control scheme. InputActionState
                        // uses disambiguation to deal with this but here, we simply don't attempt
                        // to resolve the ambiguity automatically. Instead, if you *do* want multiple
                        // concurrent bindings on the same action, you need to use composites to
                        // resolve ambiguities in a controlled manner.

                        ////TODO: support processors
                        ////TODO: support interactions

                        // Find action.
                        var action = actionMap.FindAction(binding.action);
                        if (action == null)
                            continue;

                        if (binding.isComposite)
                        {
                            var compositeNameAndParameters = NameAndParameters.Parse(binding.path);
                            switch (compositeNameAndParameters.name.ToLower())
                            {
                                case "axis":
                                case "1daxis":
                                {
                                    // Find part bindings.
                                    var negativeBindingIndex = bindings.GetComponentPartIndex(bindingIndex, "negative",
                                        controlScheme.bindingGroup);
                                    var positiveBindingIndex = bindings.GetComponentPartIndex(bindingIndex, "positive",
                                        controlScheme.bindingGroup);

                                    ////TODO: having only one and not the other should be treated as an error
                                    if (negativeBindingIndex == -1 || positiveBindingIndex == -1)
                                        continue;

                                    bindingIndex = bindings.GetNextBindingAfterComposite(bindingIndex) - 1;

                                    // Find controls.
                                    var negativeControl =
                                        InputControlPath.TryFindControl(device, bindings[negativeBindingIndex].path);
                                    var positiveControl =
                                        InputControlPath.TryFindControl(device, bindings[positiveBindingIndex].path);
                                    if (negativeControl == null || positiveControl == null)
                                        continue;

                                    if (!(negativeControl is ButtonControl))
                                        throw new NotSupportedException($"Control '{negativeControl}' used as 'negative' of axis composite is not a button");
                                    if (!(positiveControl is ButtonControl))
                                        throw new NotSupportedException($"Control '{negativeControl}' used as 'positive' of axis composite is not a button");

                                    // ATM this is super unintelligent. We only support copy ops ATM which means the source data already has
                                    // to be 1:1.

                                    var negativeId = MapControlToId(negativeControl);
                                    var positiveId = MapControlToId(positiveControl);

                                    writer.WriteLine($"transforms[{transformIndex}] = new DOTSInput.InputTransform");
                                    writer.BeginBlock();
                                    writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Combination.TwoButtonsToOneAxis),");
                                    writer.WriteLine($"InputId1 = (uint){inputFormatName}.Id.{negativeId},");
                                    writer.WriteLine($"InputId2 = (uint){inputFormatName}.Id.{positiveId},");
                                    writer.WriteLine($"OutputId = (uint)Id.{CSharpCodeHelpers.MakeIdentifier(action.name)}");
                                    writer.EndBlock(true);

                                    ++transformIndex;

                                    break;
                                }

                                case "dpad":
                                case "2dvector":
                                {
                                    // Find part bindings.
                                    var upBindingIndex = bindings.GetComponentPartIndex(bindingIndex, "up",
                                        controlScheme.bindingGroup);
                                    var downBindingIndex = bindings.GetComponentPartIndex(bindingIndex, "down",
                                        controlScheme.bindingGroup);
                                    var leftBindingIndex = bindings.GetComponentPartIndex(bindingIndex, "left",
                                        controlScheme.bindingGroup);
                                    var rightBindingIndex = bindings.GetComponentPartIndex(bindingIndex, "right",
                                        controlScheme.bindingGroup);

                                    ////TODO: having a missing part should be treated as an error
                                    if (upBindingIndex == -1 || downBindingIndex == -1 || leftBindingIndex == -1 || rightBindingIndex == -1)
                                        continue;

                                    bindingIndex = bindings.GetNextBindingAfterComposite(bindingIndex) - 1;

                                    // Find controls.
                                    var upControl =
                                        InputControlPath.TryFindControl(device, bindings[upBindingIndex].path);
                                    var downControl =
                                        InputControlPath.TryFindControl(device, bindings[downBindingIndex].path);
                                    var leftControl =
                                        InputControlPath.TryFindControl(device, bindings[leftBindingIndex].path);
                                    var rightControl =
                                        InputControlPath.TryFindControl(device, bindings[rightBindingIndex].path);
                                    if (upControl == null || downControl == null || leftControl == null || rightControl == null)
                                        continue;

                                    if (!(upControl is ButtonControl))
                                        throw new NotSupportedException($"Control '{upControl}' used as 'up' of 2D Vector composite is not a button");
                                    if (!(downControl is ButtonControl))
                                        throw new NotSupportedException($"Control '{downControl}' used as 'down' of 2D Vector composite is not a button");
                                    if (!(leftControl is ButtonControl))
                                        throw new NotSupportedException($"Control '{leftControl}' used as 'left' of 2D Vector composite is not a button");
                                    if (!(rightControl is ButtonControl))
                                        throw new NotSupportedException($"Control '{rightControl}' used as 'right' of 2D Vector composite is not a button");

                                    // ATM this is super unintelligent. We only support copy ops ATM which means the source data already has
                                    // to be 1:1.

                                    var upId = MapControlToId(upControl);
                                    var downId = MapControlToId(downControl);
                                    var leftId = MapControlToId(leftControl);
                                    var rightId = MapControlToId(rightControl);

                                    writer.WriteLine($"transforms[{transformIndex}] = new DOTSInput.InputTransform");
                                    writer.BeginBlock();
                                    writer.WriteLine("Operation = DOTSInput.ToTransformOperation(DOTSInput.Combination.FourButtonsToOneFloat2),");
                                    writer.WriteLine($"InputId1 = (uint){inputFormatName}.Id.{upId},");
                                    writer.WriteLine($"InputId2 = (uint){inputFormatName}.Id.{leftId},");
                                    writer.WriteLine($"InputId3 = (uint){inputFormatName}.Id.{downId},");
                                    writer.WriteLine($"InputId4 = (uint){inputFormatName}.Id.{rightId},");
                                    writer.WriteLine($"OutputId = (uint)Id.{CSharpCodeHelpers.MakeIdentifier(action.name)}");
                                    writer.EndBlock(true);

                                    ++transformIndex;

                                    break;
                                }

                                default:
                                    throw new NotImplementedException("composite type not supported");
                            }
                        }
                        else
                        {
                            // Ignore binding if it's not in the current control scheme.
                            if (string.IsNullOrEmpty(binding.groups) || !StringHelpers.CharacterSeparatedListsHaveAtLeastOneCommonElement(binding.groups, controlScheme.bindingGroup,
                                ';'))
                                continue;

                            // Find control.
                            var control = InputControlPath.TryFindControl(device, binding.path);
                            if (control == null)
                                continue;

                            // ATM this is super unintelligent. We only support copy ops ATM which means the source data already has
                            // to be 1:1.

                            var id = MapControlToId(control);

                            writer.WriteLine($"transforms[{transformIndex}] = new DOTSInput.InputTransform");
                            writer.BeginBlock();
                            writer.WriteLine($"Operation = DOTSInput.ToCopyOperation({sizes[action.name]}),");
                            writer.WriteLine($"InputId1 = (uint){inputFormatName}.Id.{id},");
                            writer.WriteLine($"OutputId = (uint)Id.{CSharpCodeHelpers.MakeIdentifier(action.name)}");
                            writer.EndBlock(true);

                            ++transformIndex;
                        }
                    }

                    // Add a struct mapping.
                    writer.WriteLine($"structMappings[{structMappingIndex}] = new DOTSInput.InputStructMapping");
                    writer.BeginBlock();
                    writer.WriteLine($"InputFormat = {inputFormatCode},");
                    writer.WriteLine($"OutputFormat = {outputFormatCode},");
                    writer.WriteLine($"TransformStartIndex = {transformStartIndex},");
                    writer.WriteLine($"TransformCount = {transformIndex - transformStartIndex}");
                    writer.EndBlock(true);
                    structMappingIndex++;
                }
                writer.WriteLine("return new DOTSInput.InputPipeline { Transforms = transforms, StructMappings = structMappings };");
                writer.EndBlock();
                writer.EndBlock();
                writer.WriteLine($"private const int kNumStructMappings = {structMappingIndex};");
                writer.WriteLine($"private const int kNumTransforms = {transformIndex};");

                // End component.
                writer.EndBlock();

                // System.
                writer.WriteLine($"public class {componentName}Update : InputSystem<{componentName}>");
                writer.BeginBlock();
                writer.EndBlock();

                if (haveNamespace)
                    writer.EndBlock();

                var code = writer.buffer.ToString();

                var file = Path.Combine(Path.GetDirectoryName(filePath), componentName + ".cs");
                if (File.Exists(file))
                {
                    var existingCode = File.ReadAllText(file);
                    if (existingCode == code || existingCode.WithAllWhitespaceStripped() == code.WithAllWhitespaceStripped())
                        continue;
                }

                File.WriteAllText(file, code);
                anyFileWritten = true;
            }

            return anyFileWritten;
        }

        private static string MapControlToId(InputControl control)
        {
            var devicePath = control.device.path;
            var controlPath = control.path;
            var pathOnDevice = controlPath.Substring(devicePath.Length + 1);
            var parts = pathOnDevice.Split('/');
            return string.Join("", parts.Select(p => CSharpCodeHelpers.MakeTypeName(p)));
        }

        private static void WritePaddingFields(ref InputActionCodeGenerator.Writer writer, ref int currentByteOffset, int desiredByteOffset, ref int currentPaddingCount)
        {
            while (currentByteOffset < desiredByteOffset)
            {
                if (currentByteOffset + 8 <= desiredByteOffset)
                {
                    writer.WriteLine($"private long Padding{currentPaddingCount};");
                    currentByteOffset += 8;
                }
                else if (currentByteOffset + 4 <= desiredByteOffset)
                {
                    writer.WriteLine($"private int Padding{currentPaddingCount};");
                    currentByteOffset += 4;
                }
                else if (currentByteOffset + 2 <= desiredByteOffset)
                {
                    writer.WriteLine($"private short Padding{currentPaddingCount};");
                    currentByteOffset += 2;
                }
                else
                {
                    writer.WriteLine($"private byte Padding{currentPaddingCount};");
                    ++currentByteOffset;
                }
                ++currentPaddingCount;
            }
        }

        private static int GetComponentPartIndex(this ReadOnlyArray<InputBinding> bindings, int compositeIndex, string partName, string bindingGroup)
        {
            var partIndex = -1;
            for (var index = compositeIndex + 1; index < bindings.Count && bindings[index].isPartOfComposite; ++index)
            {
                if (!bindings[index].name.Equals(partName, StringComparison.InvariantCultureIgnoreCase))
                    continue;
                if (string.IsNullOrEmpty(bindings[index].groups) ||
                    !StringHelpers.CharacterSeparatedListsHaveAtLeastOneCommonElement(bindings[index].groups, bindingGroup, ';'))
                    continue;
                if (partIndex != -1)
                    throw new NotSupportedException(
                        $"Multiple bindings for part '{partName}' of composite binding '{bindings[compositeIndex]}'");
                partIndex = index;
            }

            return partIndex;
        }

        private static int GetNextBindingAfterComposite(this ReadOnlyArray<InputBinding> bindings, int compositeIndex)
        {
            var index = compositeIndex + 1;
            while (index < bindings.Count && bindings[index].isPartOfComposite)
                ++index;
            return index;
        }
    }
}
#endif // UNITY_EDITOR
